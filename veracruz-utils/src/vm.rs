//! Shared material for all VM-like isolation mechanisms
//!
//! Material that is common to AWS Nitro Enclaves and Linux applications,
//! and similar backends.
//!
//! ## Authors
//!
//! The Veracruz Development Team.
//!
//! ## Licensing and copyright notice
//!
//! See the `LICENSE.markdown` file in the Veracruz root directory for
//! information on licensing and copyright.

use serde::{Deserialize, Serialize};

///////////////////////////////////////////////////////////////////////////////
// Status messages.
///////////////////////////////////////////////////////////////////////////////

/// The Status value returned by the enclave/application for operations.
/// This is intended to be received as a bincode serialized
/// `RootEnclaveMessage::Status`
#[derive(Serialize, Deserialize, Debug)]
pub enum VMStatus {
    /// The operation generating the message succeeded
    Success,
    /// The operation generating the message failed
    Fail,
    /// The requested operation is not yet implemented
    Unimplemented,
}

///////////////////////////////////////////////////////////////////////////////
// Command-and-control messages for the runtime manager.
///////////////////////////////////////////////////////////////////////////////

/// An enumerated type describing messages passed between to/from the Runtime
/// Manager enclave (These originate from the Untrusted Pass-through (Veracruz
/// server)
/// These messages are inteded to be serialized using bincode before transport,
/// and deserialized using bincode after transport
#[derive(Serialize, Deserialize, Debug)]
pub enum RuntimeManagerMessage {
    // A message generated by an operation that did not return data, but did
    /// return a status.
    /// Most operations return data, but if they fail, they will return a
    /// status set to `NitroStatus::Fail` (or `NitroStatus::Unimplemented` if
    /// it is not implmeneted).
    /// Parameters:
    /// NitroStatus - the Status
    Status(VMStatus),
    /// A request to initialize the Runtime Manager enclave with the provided
    /// policy
    /// parameters:
    /// String - The policy, in JSON format
    Initialize(String),  // policy_json
    /// A request for the self-signed certificate generated by the enclave.
    /// This message is necessary for allowing tests to operate without
    /// performing the full attestation flow.
    /// This command should not be used in real environments. It does not
    /// constitute a security risk in and of itself, but the fetched value
    /// cannot be trusted, and thus the certificate should actually be
    /// retrieved using attestation.
    /// This request may be removed in the future.
    GetEnclaveCert,
    /// The response to the `GetEnclaveCert` message. It contains the
    /// self-signed certificate generated by the enclave
    /// Parameters:
    /// Vec<u8> - the DER encoded certificate
    EnclaveCert(Vec<u8>),
    /// A request for the randomly generated name of the enclave.
    /// This message is necessary for allowing tests to operate without
    /// performing the full attestation flow.
    /// This command should not be used in real environments. It does not
    /// constitute a security risk in and of itself, but the fetched value
    /// cannot be trusted, and thus the name should actually be retrieved using
    /// attestation.
    /// This request may be removed in the future.
    GetEnclaveName,
    /// The response to the `GetEnclaveName` message. It contains the randomly
    /// generated name of the enclave
    /// Parameters:
    /// String - the name of the enclave
    EnclaveName(String),
    /// A request for a PSA Attestation (proxy) token from the Runtime Manager
    /// enclave.
    /// Parameters:
    /// Vec<u8> - The 128-bit randomly generated challenge value
    GetPSAAttestationToken(Vec<u8>),
    /// The response to the `GetPSAAttestationToken` request.
    /// Parameters:
    /// Vec<u8> - The PSA Attestation token
    /// Vec<u8> - The public key that was randomly generated by the enclave
    ///           to be used for the TLS channel communications
    /// i32     - The Device ID that he Nitro Root Enclave uses to identify
    ///           itself to the Proxy Attestation Service
    PSAAttestationToken(Vec<u8>, Vec<u8>, i32),
    /// A request to establish a new TLS session with the enclave
    NewTLSSession,
    /// The response to the `NewTLSSession` message
    /// Parameters:
    /// u32 - The Session ID of the created TLS Session
    TLSSession(u32),
    /// A request to close an already established TLS session
    /// Parameters:
    /// u32 - The Session ID of the session to be closed
    CloseTLSSession(u32),
    /// Request to determine if the TLS Session needs data to be sent to it
    /// Parameters:
    /// u32 - The Session ID of the TLS session
    GetTLSDataNeeded(u32),
    /// Response to `GetTLSDataNeeded` message
    /// Parameters:
    /// bool - is data needed?
    TLSDataNeeded(bool),
    /// Request to send TLS data to the enclave
    /// Parameters:
    /// u32 - the Session ID of the TLS Session associated with the data
    /// Vec<u8> - The TLS Data
    SendTLSData(u32, Vec<u8>),
    /// Request TLS Data from the enclave
    /// Parameters:
    /// u32 - the Session ID of the TLS Session to request data from
    GetTLSData(u32),
    /// Response to `GetTLSData`
    /// Parameters:
    /// Vec<u8> - The TLS Data. May be empty
    /// bool    - a flag indicating if the TLS session is still alive
    TLSData(Vec<u8>, bool),    // TLS Data, alive_flag
    /// A request to reset the enclave
    ResetEnclave,
}
